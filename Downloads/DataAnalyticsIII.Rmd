---
title: 'Data Analytics III'
author: "QBS 103: Foundations of Data Science"
date: "August 3, 2023"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


### Lesson Objectives

##### At the end of this lecture you should be able to:
1. Apply a single function across multiple rows/columns
2. Build a simple correlation plot
3. Build a heatmap
4. Understand the basic concept behind heirarchical clustering algorithms


### Additional Resources

*corrplot*: https://cran.r-project.org/web/packages/corrplot/vignettes/corrplot-intro.html

*pheatmap*: https://r-charts.com/correlation/pheatmap/


### The *apply* Function

For today's example we are going to use extracellular vesicle (EV) miRNA data. This data is currently stored as raw counts from array data in a 798x25 matrix where each row indicates a miRNA probe and each column represents a single sample.

``` {r}

# Load data (available on canvas)
load('EVmiRNA.RData')

# Look at top values of data
head(miRNA)

# Look at top 20 row (aka miRNA) names
row.names(miRNA)[1:20]

```


Sometimes, you will want to apply a single function across all the rows or columns of your data. For example, if you want to calculate the relative abundance of a given miRNA in a sample in our data set, you would first need to know the total abundance of miRNA in a sample. We can do this by looping through all the columns of our data and calculating the sum of each like this:


``` {r}

# Generate am empty vector of sums
total.miRNA <- array(dim = ncol(miRNA))
names(total.miRNA) <- colnames(miRNA)

# Look at our empty vector
total.miRNA

# Loop through each column (aka each sample)
for (sample in colnames(miRNA)) {
  # Add up all the values in that column
  total.miRNA[sample] <- sum(miRNA[,sample])
}

# Print final vector
total.miRNA

```

This requires several lines of code and there is luckily a way to do it much more cleaner in a single line of code using the *apply()* function. For this function, you will provide 3 inputs:

1. The data frame (m x n) you wan to use the apply function on (note: it will include every row and every column so ensure that the dataframe is appropriately subsetted).
2. The "margin" i.e. if you want it to perform this function on rows or columns."MARGIN = 1" indicates it should perform the function on every on every row, resulting in an array of m length and "MARGIN = 2" indicates it should perform the funciton on every column, resulting in an array of n length.
3. The function you want it to apply on those rows or columns. You can either specify a function by name or define your own in line (more on this later).

So, we can recreate the same array of totals we created in the loop above, now using a single line of code like this:

``` {r}

# Calculate the sum of each column
total.miRNA <- apply(miRNA,MARGIN = 2,FUN = 'sum')
# Look at the totals
total.miRNA

```

If we wanted to look at, say the average expression level of each miRNA in our dataset, we could also generate this easily with the apply function now using "MARGIN = 1".

``` {r}

# Calculate the average of each row
meanExp <- apply(miRNA,MARGIN = 1,FUN = mean)
# Look at the average expression of the first 10 miRNA
meanExp[1:10]

```

We can also use the apply function on our own defined functions. Last class, we created the following function to report a formatted Median (IQR) for a given variable.


``` {r}

medianIQR <- function(x) {
    # Calculate individual values
    myMedian <- round(median(x))
    myIQR1 <- round(quantile(x,1/4),digits = 2)
    myIQR2 <- round(quantile(x,3/4),digits = 2)
    # Combine values
    paste0(myMedian,' [',myIQR1,', ',myIQR2,']')
}

```

Notice that the only input required for this function is a single array. Importantly, to use the apply function it can only take input as an array because you will only ever be inputting an array of rows or an array of columns. Now we can use the apply function to calculate summary statistics as follows:

``` {r}

# Calculate median [IQR] for each row (miRNA)
medianExp <- apply(miRNA,MARGIN = 1,FUN = medianIQR)
# Look at values for first 10 miRNA
medianExp[1:10]

```

You can also define function in line, although for anything complex it is best practice to define it as a function up front. 

For example, I might be interested in the log2-normalized total miRNA content of each sample.

```{r}

# Calculate log2-total counts
apply(miRNA,MARGIN = 2,FUN = function(x) {log2(sum(x))})

```


### Correlation Plots

We can calculate correlations for any case in which we have paired data. For example, we can look at the correlation between any two miRNAs in our data set between subjects. We can calculate correlations for a data frame using the *cor()* function in R. When you use the *cor()* function, you will need to designate the method you want it to use. Typically, you will see Pearson Correlation Coefficient used for normally distributed data as it assumes a linear relationship between your two variables and you will see a Spearman's Rank Correlation Coefficient used for non-normal data as it is a non-parametric test that does not assume linearity.

The *cor()* function takes the input of a data frame and will calculate the correlation between each column of your data frame. So, if we use our data frame where columns reflect samples, it will tell us the correlation between each sample. 

``` {r}
#install.packages('corrplot')
library(corrplot)

# Calculate the spearman correlation coefficient
corrMatrix <- cor(miRNA,method = 'spearman')
# Generate a circle-based plot
corrplot(corrMatrix,method = 'circle')
# Generate a color-based correlation plot
corrplot(corrMatrix,method = 'color')

```

We can also produce a plot with the individual correlations included, but it's easier to see this with a smaller plot.

``` {r}

# Generate plot with absolute correlations
corrplot(corrMatrix[1:5,1:5],method = 'number')

```

If we want to generate the correlations between each miRNA we first need to transpose the matrix (i.e. make the columns the rows and the rows the columns).

``` {r}

# Transpose a subset of the matrix
t(miRNA[1:10,1:10])

```

Here, we can see our miRNA are now in the columns, so that when we use the *cor()* function it will calculate between-miRNA correlations instead of between sample correlations.

``` {r}
miRNA

# Calculate correlations
miRNA.cor <- cor(t(miRNA),method = 'spearman')

# Plot correlations
corrplot(miRNA.cor[1:10,1:10],method = 'circle')

```

### Heat Maps

Heat maps are an easy way to visualize data and look for overall trends when working with highly dimensional data. There are many packages you can use to generate heatmaps but today we're going to work with *pheatmap* which has really easy functionality.

To start, we're going to identify miRNA in our data that have the most variability so that we can have a more interesting heatmap to look at. Variance is just a measure of how much values within a set of numbers differ from the mean. So, the set {3,3.5,4} would have a much lower variance than the set {0,2.5,8} even though they both have the same mean. The formula for variance looks like this:

$$ \sigma^2 = \frac{\displaystyle\sum_{i=1}^{n}(x_i - \mu)^2} {n} $$

In R, we can calculate this using the *var()* function:

```{r}

# Compare sample variances
var(c(3,3.5,4))
var(c(0,2.5,8))

```

Notably, standard deviation is just the square root of variance, which we can see easily here.

``` {r}

# Calculate variance
var(c(0,2.5,8))
# Calculate the sd squared
sd(c(0,2.5,8))^2

```

Now, we can use the apply function to calculate these values quickly for all the 798 miRNA in our dataset.

```{r}

# Calculate variance of each miRNA
variance <- apply(miRNA,MARGIN = 1,FUN = var)
# Order rows of miRNA so that highest variance in expression is on top
miRNA <- miRNA[order(variance,decreasing = T),]

# Log2-normalize data for plotting
log2.miRNA <- log2(miRNA)

```

Now that we have our data ready, we can generate a very simple heatmap. 

``` {r}

#install.packages('pheatmap')
library(pheatmap)

# Generate heatmap without clustering
pheatmap(log2.miRNA[1:20,],
         cluster_rows = F,
         cluster_cols = F)

```

### Basic Hierarchical Clustering

Clustering is a way of identifying how similar different samples, etc. are from each other in our data. We often add clustering to heat maps to help us visualize how similar vs. dissimilar different rows and columns are from one another. There are lots of different algorithms you can use for clustering but for the sake of this lecture, we're just going to talk about Euclidean distance as that is a common default for heatmaps. The equation for Euclidean distance looks like this:

$$  d\left( p,q\right)   = \sqrt {\sum _{i=1}^{n}  \left( q_{i}-p_{i}\right)^2 }  $$

We can calculate this value between every combination of samples or miRNAs in our data and then create a dendrogram by designating which values are closer to each other, or less close to each other. Every time you assign one set of samples as closer to each other, you will calculate distance again between that now cluster of samples, and all other remaining samples, iteratively until all samples have been linked. Ultimately, the end product looks like this:


```{r}

# Add clusters (note: euclidean is actually default so as long as clustering is turned on this is what you will get)
pheatmap(log2.miRNA[1:20,],
         clustering_distance_cols = 'euclidean',
         clustering_distance_rows = 'euclidean')

```


An important thing to remember when ever you're looking at a clustering dendrogram is that not all order matters. Technically, any point it branches off it can pivot on that access so ultimately, Subject10 could end up next to Subject8, Subject21, Subject25, or any of the other members of that cluster. 

Now we can start to see our samples breaking out into 2 primary clusters. We may want to visualize additional things, such as if this clustering pattern is related to a covariate of interest.

``` {r}
annotationData
# Define covariate for tracking bar
set.seed(9876)
annotationData <- data.frame(row.names = colnames(miRNA),
                             'Status' = c(factor(rbinom(n = 25,size = 1,prob = 0.6),labels = c('Disease X','Healthy'))))
annotationColors <- list(Status = c('Disease X' = 'aquamarine4',
                                    'Healthy' = 'deepskyblue4'))
annotationColors
# Generate heatmap
pheatmap(log2.miRNA[1:20,],
         clustering_distance_cols = 'euclidean',
         clustering_distance_rows = 'euclidean',
         annotation_col = annotationData,
         annotation_colors = annotationColors)
```


### In Class Acitivity

1. Write a function to calculate the relative abundance of each miRNA in each sample. Verify that each sample has a total relative abundance of 1.

2. Using the apply function, identify the highest relative abundance each miRNA has in a single sample.

3. Sort the dataset by miRNA with the highest relative abundance and generate a heatmap of the relative abundance (not the absolute counts) of each miRNA, including the top 20 miRNA by single-sample relative abundance.

4. Generate a random binary variable for sex and a categorical variable for age group using distributions and age cutoffs (hint: use the *cut()* function) of your chosing. Add tracking bars to your plot for your generated variables.

```{R}

```
